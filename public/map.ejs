<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Special Transportation Information</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <!-- Font Awesome CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
    }
    h1 {
      text-align: center;
      margin: 20px 0;
    }
    #map {
      height: 600px;
      width: 100%;
      position: relative;
      margin-top: 120px; 
    }
    .button-container {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px; /* 버튼 사이의 여백 */
      z-index: 1000;
    }
    .button-container button {
      padding: 10px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      color: white;
      display: flex;
      align-items: center;
    }
    #recenter-button {
      background-color: #007bff;
    }
    #toggle-location-button {
      background-color: #28a745; /* 녹색 */
    }
    #recenter-button i, #toggle-location-button i {
      margin-right: 5px;
    }
    #recenter-button:hover {
      background-color: #0056b3;
    }
    #toggle-location-button:hover {
      background-color: #218838; /* 더 어두운 녹색 */
    }
    #toggle-location-button.active {
      background-color: #218838; /* 더 어두운 녹색 */
    }

    /* 사용자 ID 입력 폼 */
    .user-input-container {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      display: flex;
      gap: 10px;
      margin-top: 50px; 
    }
    .user-input-container input {
      border: 1px solid #ccc;
      border-radius: 5px;
      font-size: 16px;
    }
    .user-input-container button {
      padding: 10px 15px;
      background-color: #007bff;
      border: none;
      color: white;
      cursor: pointer;
      border-radius: 5px;
      font-size: 16px;
    }
    .user-input-container button:hover {
      background-color: #0056b3;
    }
  </style>
</head>
<body>
  <h1>Special Transportation Information</h1>
  
  <!-- 사용자 ID 입력 폼 -->
  <div class="user-input-container">
    <input type="text" id="userIdInput" placeholder="Enter User ID" />
    <input type="text" id="movementIdInput" placeholder="Enter Movement ID" />
    <button id="searchUserPathButton">Search User Path</button>
  </div>
  
  <div id="map">
    <div class="button-container">
      <button id="toggle-location-button">
        <i class="fas fa-location-arrow"></i> Toggle Location Tracking
      </button>
      <button id="recenter-button">
        <i class="fas fa-sync-alt"></i> Map Centered Re-search
      </button>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const map = L.map("map").setView([37.5665, 126.978], 13);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: "© OpenStreetMap contributors",
    }).addTo(map);

    const startIcon = L.divIcon({
      className: "custom-icon",
      html: '<i class="fas fa-play" style="color: green; font-size: 24px;"></i>', // Start icon (green play icon)
      iconSize: [32, 32],
    });

    const endIcon = L.divIcon({
    className: "custom-icon",
    html: '<i class="fas fa-stop" style="color: red; font-size: 24px;"></i>', // End icon (red stop icon)
    iconSize: [32, 32],
  });


    const walkIcon = L.divIcon({
      className: "custom-icon",
      html: '<i class="fas fa-walking" style="color: orange; font-size: 24px;"></i>',
      iconSize: [32, 32],
    });

    const trafficIcon = L.divIcon({
      className: "custom-icon",
      html: '<i class="fas fa-car" style="color: red; font-size: 24px;"></i>',
      iconSize: [32, 32],
    });

    let userMarker;
    let radiusCircle;
    let locationIntervalId;

    function formatDate(isoDateString) {
      const date = new Date(isoDateString);
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, "0");
      const day = String(date.getDate()).padStart(2, "0");
      const hours = String(date.getHours()).padStart(2, "0");
      const minutes = String(date.getMinutes()).padStart(2, "0");
      return `${year}-${month}-${day} ${hours}:${minutes}`;
    }

    function createMarker({
      latitude,
      longitude,
      title,
      address,
      start_dtm,
      end_dtm,
      update_dtm,
      icon,
      year,
      occxrrnc_cnt,
    }) {
      const marker = L.marker([latitude, longitude], { icon }).addTo(map);

      let popupContent = `<b>${title ? title : address}</b><br>`;
      if (start_dtm) popupContent += `Start: ${formatDate(start_dtm)}<br>`;
      if (end_dtm) popupContent += `End: ${formatDate(end_dtm)}<br>`;
      if (update_dtm) popupContent += `Last Updated: ${formatDate(update_dtm)}<br>`;
      if (occxrrnc_cnt) popupContent += `Occurrence Count: ${occxrrnc_cnt}<br>`;
      if (year) popupContent += `Year: ${year}<br>`;

      marker.bindPopup(popupContent);
    }


    // 사용자 경로를 그리는 함수
    function drawUserPath(pathData) {
      const latLngs = pathData.map((data) => {
        const wkt = data.user_location;
        // wkt 데이터를 LatLng로 변환 (가정: POINT 형식의 WKT)
        const point = wkt.match(/\(([^)]+)\)/)[1].split(" ");
        return [parseFloat(point[1]), parseFloat(point[0])]; // [latitude, longitude]
      });

      map.setView(latLngs[0], 15);

      // 경로 폴리라인 그리기
      L.polyline(latLngs, { color: "blue", weight: 4 }).addTo(map);

      // 경로의 시작과 끝에 마커 표시
      if (latLngs.length > 0) {
        const start = latLngs[0];
        const end = latLngs[latLngs.length - 1];
        L.marker(start, { icon: startIcon }).bindPopup("Start").addTo(map);
        L.marker(end, { icon: endIcon }).bindPopup("End").addTo(map);
      }
    }


    async function fetchUserPathCall(url) {
      const response = await fetch(url, {
        headers: {
            "Content-Type": "application/json",
            authKey: "<%= authKey %>",
          },
      });
      return response
    }

    async function fetchAlert4Path(url, icon) {
      
      const trafficResponse = await fetchUserPathCall(url)
      
      if (trafficResponse.status !== 200) {
        return;
      }

      const trafficData = await trafficResponse.json();

      // 이벤트 마커 찍기
      trafficData.forEach((incident) => {
        createMarker({
          ...incident,
          icon,
        });
      });

    }
    async function fetchUserPath(userId, movementId) {
      clearMarkers();
      
      const url = `/user-path?userId=${userId}&movementId=${movementId}`;
      const response = await fetchUserPathCall(url)
      if (response.status !== 200) {
        alert("Failed to fetch user path");
        return;
      }

      const userPathData = await response.json();

      // 사용자 경로 그리기
      drawUserPath(userPathData);

      await fetchAlert4Path(`/user-path-traffic-alert?userId=${userId}&movementId=${movementId}`, trafficIcon);
      await fetchAlert4Path(`/user-path-walk-alert?userId=${userId}&movementId=${movementId}`, walkIcon);
    }

    document.getElementById("searchUserPathButton").addEventListener("click", () => {
      const userId = document.getElementById("userIdInput").value;
      const movementId = document.getElementById("movementIdInput").value;
      if (userId && movementId) {
        fetchUserPath(userId, movementId);
      } else {
        alert("Please enter ID.");
      }
    });

    function clearMarkers() {
      if (radiusCircle) {
        map.removeLayer(radiusCircle);
      }
      map.eachLayer((layer) => {
        if (layer instanceof L.Marker || layer instanceof L.Polyline) {
          map.removeLayer(layer);
        }
      });
    }


    async function fetchData(url, icon) {
      try {
        const response = await fetch(url, {
          headers: {
            "Content-Type": "application/json",
            authKey: "<%= authKey %>",
          },
        });

        if (response.status !== 200) {
          throw new Error("Failed to fetch data");
        }

        const data = await response.json();
        return data.map((incident) => ({
          ...incident,
          icon,
        }));
      } catch (error) {
        console.error("Error fetching data:", error);
        return [];
      }
    }
    
    function drawRadiusCircle(lat, lon, radius) {
      if (radiusCircle) {
        map.removeLayer(radiusCircle);
      }
      radiusCircle = L.circle([lat, lon], {
        color: "blue",
        fillColor: "#0000ff",
        fillOpacity: 0.2,
        radius: radius,
      }).addTo(map);
    }

    async function changeLocation(lat, lon) {
      clearMarkers();

      drawRadiusCircle(lat, lon, 5000); // Draw a 5km circle

      const walkAlerts = await fetchData(
        `/walk-alert?lat=${lat}&lon=${lon}&radius=5000`,
        walkIcon
      );
      walkAlerts.forEach((incident) => createMarker(incident));

      const trafficAlerts = await fetchData(
        `/traffic-alert?lat=${lat}&lon=${lon}&radius=5000`,
        trafficIcon
      );
      trafficAlerts.forEach((incident) => createMarker(incident));
    }


    function startLocationTracking() {
      if (locationIntervalId) {
        clearInterval(locationIntervalId);
      }

      locationIntervalId = setInterval(() => {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(onLocationFound, onLocationError);
        } else {
          alert("Geolocation is not supported by this browser.");
        }
      }, 5000);
    }

    function stopLocationTracking() {
      if (locationIntervalId) {
        clearInterval(locationIntervalId);
        locationIntervalId = null;
      }
    }

    function onLocationFound(e) {
      const { latitude, longitude } = e.coords;

      changeLocation(latitude, longitude);
      if (userMarker) {
        map.removeLayer(userMarker);
      }

      userMarker = L.marker([latitude, longitude], {
        icon: L.icon({
          iconUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
        }),
      })
        .addTo(map)
        .bindPopup("You are here!")
        .openPopup();

      map.setView([latitude, longitude], 15);


    }

    function onLocationError(e) {
      console.error("Error retrieving location:", e.message);
      const button = document.getElementById("toggle-location-button");
      button.classList.remove("active");
      button.innerHTML = '<i class="fas fa-location-arrow"></i> Toggle Location Tracking';
      stopLocationTracking();
      alert("Unable to retrieve your location.");
    }


    document.getElementById("recenter-button").addEventListener("click", () => {
      const center = map.getCenter();
      changeLocation(center.lat, center.lng);
    });

    document.getElementById("toggle-location-button").addEventListener("click", () => {
      const button = document.getElementById("toggle-location-button");

      if (button.classList.contains("active")) {
        button.classList.remove("active");
        button.innerHTML = '<i class="fas fa-location-arrow"></i> Toggle Location Tracking';
        stopLocationTracking();
      } else {
        button.classList.add("active");
        button.innerHTML = '<i class="fas fa-stop"></i> Stop Tracking';
        startLocationTracking();
      }
    });

    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(onLocationFound, onLocationError);
    } else {
      alert("Geolocation is not supported by this browser.");
    }
  </script>
</body>
</html>
